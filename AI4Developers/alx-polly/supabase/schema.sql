-- ALX Polly â€“ Supabase schema for polls and votes
-- Run this in the Supabase SQL editor (or via migrations)

-- 1) Profiles (mirror of auth.users for convenience)
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  name text,
  avatar_url text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create or replace function public.handle_profile_updated()
returns trigger language plpgsql as $$
begin
  new.updated_at := now();
  return new;
end;$$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute function public.handle_profile_updated();

alter table public.profiles enable row level security;

-- Anyone can read profiles; users can upsert their own row
drop policy if exists "profiles_read_all" on public.profiles;
create policy "profiles_read_all" on public.profiles
for select using (true);

drop policy if exists "profiles_modify_own" on public.profiles;
create policy "profiles_modify_own" on public.profiles
for all using (auth.uid() = id) with check (auth.uid() = id);


-- 2) Polls
create table if not exists public.polls (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  description text,
  allow_multi boolean not null default false,
  closes_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_polls_user_id on public.polls(user_id);

create or replace function public.handle_polls_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at := now();
  return new;
end;$$;

drop trigger if exists trg_polls_updated_at on public.polls;
create trigger trg_polls_updated_at
before update on public.polls
for each row execute function public.handle_polls_updated_at();

alter table public.polls enable row level security;

-- Polls are readable by anyone
drop policy if exists "polls_read_all" on public.polls;
create policy "polls_read_all" on public.polls
for select using (true);

-- Only authenticated users can create; must own created rows
drop policy if exists "polls_insert_auth_only" on public.polls;
create policy "polls_insert_auth_only" on public.polls
for insert with check (auth.role() = 'authenticated' and user_id = auth.uid());

-- Owners can update/delete their polls
drop policy if exists "polls_owner_mutate" on public.polls;
create policy "polls_owner_mutate" on public.polls
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


-- 3) Poll Options
create table if not exists public.poll_options (
  id bigint generated by default as identity primary key,
  poll_id bigint not null references public.polls(id) on delete cascade,
  text text not null,
  position int not null default 0,
  created_at timestamptz not null default now()
);

create index if not exists idx_options_poll_id on public.poll_options(poll_id);

alter table public.poll_options enable row level security;

-- Read options of any poll
drop policy if exists "options_read_all" on public.poll_options;
create policy "options_read_all" on public.poll_options
for select using (true);

-- Only poll owners can modify options (insert/update/delete)
drop policy if exists "options_owner_mutate" on public.poll_options;
create policy "options_owner_mutate" on public.poll_options
for all using (
  exists (
    select 1 from public.polls p
    where p.id = poll_id and p.user_id = auth.uid()
  )
) with check (
  exists (
    select 1 from public.polls p
    where p.id = poll_id and p.user_id = auth.uid()
  )
);


-- 4) Votes (single-vote-per-poll by default)
create table if not exists public.votes (
  id bigint generated by default as identity primary key,
  poll_id bigint not null references public.polls(id) on delete cascade,
  option_id bigint not null references public.poll_options(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  unique (poll_id, user_id)
);

create index if not exists idx_votes_poll_id on public.votes(poll_id);
create index if not exists idx_votes_user_id on public.votes(user_id);

-- Ensure option belongs to the same poll via trigger
create or replace function public.check_vote_option_matches_poll()
returns trigger language plpgsql as $$
declare
  opt_poll_id bigint;
begin
  select poll_id into opt_poll_id from public.poll_options where id = new.option_id;
  if opt_poll_id is null or opt_poll_id <> new.poll_id then
    raise exception 'Option % does not belong to poll %', new.option_id, new.poll_id;
  end if;
  return new;
end;$$;

drop trigger if exists trg_votes_check_option on public.votes;
create trigger trg_votes_check_option
before insert or update on public.votes
for each row execute function public.check_vote_option_matches_poll();

alter table public.votes enable row level security;

-- Anyone can read aggregate votes; only owners of a vote can write, and only if authenticated
drop policy if exists "votes_read_all" on public.votes;
create policy "votes_read_all" on public.votes
for select using (true);

drop policy if exists "votes_insert_owner" on public.votes;
create policy "votes_insert_owner" on public.votes
for insert with check (auth.role() = 'authenticated' and user_id = auth.uid());

drop policy if exists "votes_update_delete_owner" on public.votes;
create policy "votes_update_delete_owner" on public.votes
for update using (user_id = auth.uid()) with check (user_id = auth.uid());


-- Optional helper view for results
create or replace view public.poll_results as
select
  o.poll_id,
  o.id as option_id,
  o.text as option_text,
  count(v.id) as votes
from public.poll_options o
left join public.votes v on v.option_id = o.id
group by o.poll_id, o.id, o.text
order by o.poll_id, o.position, o.id;


